# Updated by PZ, 2021-07-07
# 1 Fixed a bug leading to wrong location site of smORF on antisense strand
# 2 To output two additional files: the total smORFs fasta and a bed file
# 3 To print output real-time, not after completion of processing
# See details in search_sORF.remake.v1.pl and search_sORF.remake.v2.pl

use POSIX qw(strftime);

$direc="s";

for(my $i=0; $i<@ARGV; $i++){
        if($ARGV[$i] eq "-m"){
                $MATRIX=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-s"){
                $PP_DST=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-i"){
                $FASTA=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-p"){
                $ratio=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-d"){
                $direc=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
        elsif($ARGV[$i] eq "-o"){
                $OUT=$ARGV[$i+1]; $ARGV[$i]=-1; $ARGV[$i+1]=-1;
        }
}

if(@ARGV==0){
	print "search_sORF.pl -m matrix_file -s simulation_file -i target_file -o output_file\n";
	print "\n";
	print "---Option----\n";
	print "-m (required) matrix file generated by make_model.pl\n";
	print "-s (required) simulation results generated by simulate.pl\n";
	print "-i (required) target input sequences\n";
	print "-o (required) output files prefix\n";
	print "-p (required) proportion(p) of coding sequence in genome(0.01<p<0.5): should be the same value used in simulation_file\n";
	print "-d only sens(s) or both sens and antisens(b): defalt is only sens direction\n";
	exit 1;
}
for(my $i=0; $i<@ARGV; $i++){
        if($ARGV[$i]!=-1){
		print "search_sORF.pl -m matrix_file -s simulation_file -i target_file -o output_file\n";
		print "\n";
		print "---Option----\n";
		print "-m (required) matrix file generated by make_model.pl\n";
		print "-s (required) simulation results generated by simulate.pl\n";
		print "-i (required) target input sequences\n";
		print "-p proportion(p) of coding sequence in genome(0.01<p<0.5): defalt is 0.5\n";
		print "-d only sens(s) or both sens and antisens(b): defalt is only sens direction\n";
		exit 1;
        }
}

unless(-f $PP_DST){
        print "can not find file (simulation results): $PP_DST\n";
        exit 1;
}
unless(-f $MATRIX){
        print "can not find file (matrix): $MATRIX\n";
        exit 1;
}
unless(-f $FASTA){
        print "can not find file (input sequences): $FASTA\n";
        exit 1;
}
if($ratio<0.01 or $ratio>0.5){
        print "the proportion(p) of coding sequence is not correct range. Please use the range(0.01<p<0.5)\n";
        exit 1;
}
unless($direc eq "s" or $direc eq "b"){
        print "direction should be s(only sens) or b(both sens and anti-sens) direction\n";
        exit 1;
}

$ORDER =5;

%aalist = qw(
atg	M	tat     Y	gca     A       gcc     A
gcg     A       gct     A	tgc     C       tgt     C
gac     D       gat     D	gaa     E       gag     E
ttt     F       ttc     F	gga     G       ggc     G
ggg     G       ggt     G	cac     H       cat     H
ata     I       atc     I	att     I       aaa     K
aag     K       tta     L	ttg     L       cta     L
ctc     L       ctg     L	ctt     L       tgg     W
aac     N       aat     N	cca     P       ccc     P
ccg     P       cct     P	caa     Q       cag     Q
aga     R       agg     R	cga     R       cgc     R
cgg     R       cgt     R	agc     S       agt     S
tca     S       tcc     S	tcg     S       tct     S
aca     T       acc     T	acg     T       act     T
gta     V       gtc     V	gtg     V       gtt     V
tac     Y	taa	.	tag     .       tga     .
);

##
open(LOG, "> ${OUT}_log");
print LOG strftime("%Y-%m-%d %H:%M:%S", localtime(time))."\tTask starts.\n";

open(IN, $MATRIX);
while(<IN>){
	if(/^Order\s\=\s(\d+),\sFrame\s+\=\s+(\d+)/){
		$order=$1;
		$frame=$2;
	}
	elsif(/^([ATGC]+)\s+\d+\s+\((\d+\.\d{4})/){
		$matrix=$order.$frame;
		$$matrix{$1}=$2;
	}
}
close IN;
print LOG strftime("%Y-%m-%d %H:%M:%S", localtime(time))."\tMatrix processing is completed.\n";

open(IN, $PP_DST);
while(<IN>){
	if(/^(\d+)\s+NCDS\s+(\S.*)\n/){
		$len=$1;
		@ncds_p=split(/\s+/,$2);
		@ncds_p=sort {$b<=>$a} @ncds_p;
		$SUM=0;
		for(my $n=5; $n<15; $n++){
			$SUM=$SUM+$ncds_p[$n];
		}
		$AV=$SUM/10;
		$FalseP{$len}=$AV;
	}
	if(/^(\d+)\s+CDS\s+(\S.*)\n/){
		$len=$1;
		@cds_p=split(/\s+/,$2);
		@cds_p=sort {$a<=>$b} @cds_p;
		$SUM=0;
		for(my $n=5; $n<15; $n++){
			$SUM=$SUM+$cds_p[$n];
		}
		$AV=$SUM/10;
		$FalseN{$len}=$AV;
		$PP=join(",",@cds_p);
		$PP_cds{$len}=$PP;
	}
}
close IN;
print LOG strftime("%Y-%m-%d %H:%M:%S", localtime(time))."\tSimulate processing is completed.\n";

########## MAIN ##########
open(in, $FASTA);
while(<in>){
	if(/^>(\S+)/){
		$name=$1;
		push(@NAME,$name);
	}
	elsif(/(\S+)/){
		$SEQ{$name}=$SEQ{$name}.$1;
	}
}
close in;
print LOG strftime("%Y-%m-%d %H:%M:%S", localtime(time))."\tInput fasta processing is completed.\n";

open(out1, "> ${OUT}_total.fa");
open(out2, "> ${OUT}_sORF.fa");
open(out3, "> ${OUT}_total.bed");
open(out4, "> ${OUT}_sORF.bed");


$total=0;
for(my $i=0; $i<@NAME; $i++){
	$otu=$NAME[$i]; 
	if($direc eq "s" or $direc eq "b"){
		$frame_seq=substr($SEQ{$otu},0);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",0);

		$frame_seq=substr($SEQ{$otu}, 1);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",1);

		$frame_seq=substr($SEQ{$otu}, 2);
		($S,$I)=&orf60($otu, $frame_seq);
		&coding_sORF($NAME[$i],$S,$I,"+",2);
	}
	if($direc eq "b"){
		$length_seq=length($SEQ{$otu});

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),0);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-0;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),1);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-1;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);

		$frame_seq=substr(&reverse_seq($SEQ{$otu}),2);
		($S,$I)=&orf60($otu, $frame_seq);
		$last_site=$length_seq-2;
		&coding_sORF($NAME[$i],$S,$I,"-",$last_site);
	}
}

sub coding_sORF{
	my $N=shift; my $S=shift; my $I=shift;
	my $D=shift; my $Start=shift;
	@tmp_s=@$S; @tmp_i=@$I;
	for(my $n=0; $n<@tmp_s; $n++){
		$l=length($tmp_s[$n])-3;
		if($l<29){next;}
		if($l>302){next;}
		$total++;

		$SEQ=substr($tmp_s[$n], 0, -3) ;
		$ci=&PP_calc($SEQ);
		if($D eq "+"){
			$TMP_I=$tmp_i[$n]+$Start;
			$TMP_E=$TMP_I+length($tmp_s[$n])
		}
		elsif($D eq "-"){
			$TMP_I=$Start-$tmp_i[$n];
			$TMP_E=$TMP_I-length($tmp_s[$n])
		}
		@pp=split(/,/,$PP_cds{$l});
		$pp_s=0;
		for(my $s=0; $s<@pp; $s++){
			if($pp[$s]<=$ci){$pp_s++;}
		}
		$PP_S=int($pp_s*1000/@pp+0.5)/10;

		print out1 ">$N#$TMP_I#$D#$PP_S\n";
		&seq60($tmp_s[$n], out1);

		($s_site, $e_site)=sort {$a<=>$b} ($TMP_I, $TMP_E);
		print out3 "$N\t$s_site\t$e_site\t$N#$TMP_I#$D#$PP_S\t$PP_S\t$D\n";

		if($ci>$FalseP{$l} and $ci>$FalseN{$l}){
			print out2 ">$N#$TMP_I#$D#$PP_S\n";
			&seq60($tmp_s[$n], out2);
			print out4 "$N\t$s_site\t$e_site\t$N#$TMP_I#$D#$PP_S\t$PP_S\t$D\n";
			$num++;
		}
	}
}
close out1;close out2;close out3;close out4;

print LOG "## Find total $total sORF\n";
print LOG "## Identify $num coding sORF\n";
print LOG "## fasta format of coding sORF ---";
print LOG "## Name is \"Seq_name#Start_site#Direction#Score\"\n";
print LOG strftime("%Y-%m-%d %H:%M:%S", localtime(time))."\tTask ends.\n";
close LOG;

sub seq60{
        my ($aa_seq, $aa_out);
        $aa_seq=shift; $aa_out=shift;
        while($aa_seq ne "" ){
                $b = substr ($aa_seq, 0, 60);
                $aa_seq = substr ($aa_seq,60);
                print $aa_out "$b\n";
        }
}

sub orf60{
	my($otu, $frame, $seq, $aa_seq, $num);
	$otu=shift; $seq=shift;
	undef $aa_seq; $num=0; undef @A_seq; undef @S_site;
	undef $start;
	for(my $i=0; $i <= length($seq)/3; $i++){
		$cod = substr($seq, $i*3,3);
		$cod =~ tr/A-Z/a-z/;
		$not_det=0;
		if($cod =~ /[atgc]{3}/){
			$not_det=1;
		}
		if($aalist{$cod} eq "M" and $start eq ""){
			$start=$i;
		}
		if($not_det==0){
			undef $aa_seq;
			undef $start;
		}
		if($not_det==1 and $start ne ""){
			$aa_seq = $aa_seq.$cod;
		}
		if($aalist{$cod} eq "."){
			 if(length($aa_seq)>32){
				$aa_seq =~ tr/a-z/A-Z/;
				push(@A_seq, $aa_seq);
				push(@S_site,$start*3);
			}
			undef $aa_seq; undef $start;
		}
	}
	return(\@A_seq,\@S_site);	
}

sub reverse_seq{
	my ($seq, $real_seq, @nor_seq, @rev_seq);
	undef $real_seq; undef @nor_seq; undef @rev_seq;
	$seq=shift;
	@nor_seq=split(//, $seq);
	@rev_seq = reverse @nor_seq;
	for(my $i =0; $i < @rev_seq; $i++){
		if(($rev_seq[$i] eq "A") or ($rev_seq[$i] eq "a")){
			$real_seq = $real_seq."T";	
		}
		elsif(($rev_seq[$i] eq "T") or ($rev_seq[$i] eq "t")){
			$real_seq = $real_seq."A";	
		}
		elsif(($rev_seq[$i] eq "G") or ($rev_seq[$i] eq "g")){
			$real_seq = $real_seq."C";	
		}
		elsif(($rev_seq[$i] eq "C") or ($rev_seq[$i] eq "c")){
			$real_seq = $real_seq."G";
		}
		else{
			$real_seq = $real_seq."N";
		}	
	}
	return ($real_seq);
}

sub chech_seq{
        my ($seq, @nu);
        $seq=shift;
        @nu=split(//, $seq);
        $sign=1;
        for(my $i=0; $i<@nu; $i++){
                if($nu[$i]=~/[ATGC]/){
                }
                else{
                        $sign=-1;
                }
        }
        return($sign);
}
			
sub PP_calc{
	my($TARGET, $sign, $first_F, $order, @PFC, $ci);
	$sign=0; undef @PFC;

	$TARGET=shift;

	$sign=&chech_seq($TARGET);
	if($sign==1){
		$ci=0;
		$S=0;
		$target_win=substr($TARGET,$S,30);
		while(length($target_win)>=30){
			for(my $frame=0; $frame<=6; $frame++){
				$first_F=substr($target_win, 0, $ORDER);
				$order=$ORDER-1;
				$matrix=$order.$frame;
				$PFC[$frame]=$$matrix{$first_F};
			}
			for(my $frame=0; $frame<=6; $frame++){
				for(my $k=0; $k<30-$ORDER; $k++){
					$F=substr($target_win, $k, $ORDER);
					$next_NT=substr($target_win, $k+$ORDER, 1);

					if($frame==0){$nextframe=0;}
					elsif(1<=$frame and $frame <=3){$nextframe=($frame-1+$k)%3+1;}
					elsif(4<=$frame and $frame <=6){$nextframe=($frame-4+$k)%3+4;}
					$matrix=$ORDER.$nextframe; $SEG=$F."A";  $probA=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."T";  $probT=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."G";  $probG=$$matrix{$SEG};
					$matrix=$ORDER.$nextframe; $SEG=$F."C";  $probC=$$matrix{$SEG};
	
					if($probA>=0 and $probT>=0 and $probG>=0 and $probC>=0){
						$sigma=$probA+$probT+$probG+$probC;
						if($sigma==0){
							$condprob=0.001;
						}
						elsif($next_NT eq "A"){
							$condprob=$probA/$sigma;
						}
						elsif($next_NT eq "T"){
							$condprob=$probT/$sigma;
						}
						elsif($next_NT eq "G"){
							$condprob=$probG/$sigma;
						}
						elsif($next_NT eq "C"){
							$condprob=$probC/$sigma;
						}
						else{
							die "stop 1\n";
						}
					}		
					else{
						die "stop 2\n";
					}
					$PFC[$frame]=$PFC[$frame]*$condprob;
				}
			}
			for(my $frame=0; $frame<=6; $frame++){
				$A=1/(1-$ratio);
				$B=6/$ratio;
				if($frame==0){ $div = $PFC[$frame]/$A;}
				else{ $div = $div+$PFC[$frame]/$B;}
			}
			if($PFC[0]==0 and $PFC[1]==0 and $PFC[2]==0 and $PFC[3]==0 and $PFC[4]==0 and $PFC[5]==0 and $PFC[6]==0){
				$S=$S+3;
				$target_win=substr($TARGET,$S,30);
				next;
			}
			@PP=($PFC[0]/$A/$div,$PFC[1]/$B/$div,$PFC[2]/$B/$div,$PFC[3]/$B/$div,$PFC[4]/$B/$div,$PFC[5]/$B/$div,$PFC[6]/$B/$div);
			$ci=$ci+$PFC[1]/$B/$div;
			$S=$S+3;
			$target_win=substr($TARGET,$S,30);
		}
		return($ci);
	}
	else{
		return(-1);
	}
}

